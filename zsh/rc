# Evaluates to an iso-conformant date.  The iso-conformance is good because
# lexicographic order coincides with date order.  'nows' just has seconds and
# is also iso-conformant.
alias now="date '+%Y-%m-%dT%H%M'";
alias nows="date '+%Y-%m-%dT%H%M%S'";
alias today="date '+%Y-%m-%d'";
alias a="$COREUTILS_LS -Frth --color=always";
alias al="$COREUTILS_LS -Frth --color=always -l";
alias aa="$COREUTILS_LS -Frth --color=always -a";
alias aal="$COREUTILS_LS -Frth --color=always -al";
alias shuf="$COREUTILS_SHUF"
alias cpptags="$UNIVERSAL_CTAGS --c++-kinds=+pf --c-kinds=+p --fields=+imaSft --extra=+q -Rnu";
alias c="clear";
alias p="pwd";
# there's always a story behind aliases like these
alias rm="rm -i";
alias top="git rev-parse --show-toplevel";
alias ztl="vim -c ':cd %:p:h' \"$HOME\"'/thearchive/writing-projects.otl'"
if [[ "$(uname)" == "Darwin" ]]; then
  alias lldb="PATH=/usr/bin:$PATH lldb"
fi

zshaddhistory() {
  emulate -L zsh
  ## uncomment if HISTORY_IGNORE
  ## should use EXTENDED_GLOB syntax
  setopt extendedglob
  [[ $1 != ''${~HISTORY_IGNORE} ]]
}
setopt pushd_ignore_dups
setopt ignoreeof # I hit ctrl-d *all the time*, never to exit

# case insensitive partial filename completion (??)
zstyle ':completion:*' matcher-list \
  'm:{[:lower:]}={[:upper:]}' \
  '+r:|[._-]=* r:|=*' \
  '+l:|=*'

# alias average="Rscript -e 'd<-scan(\"stdin\", quiet=TRUE)' -e 'cat(min(d), max(d), median(d), mean(d), sep=\"\n\")'"

# Greps and displays with less, with colors
function rgl {
    rg --line-buffered --pretty "$@" | less -R
}
# Greps and fuzzy selects
function rgfzf {
    rg "$@" | fzf
}
function sortinplace {
  sort "$1" | sponge "$1"
}

# Setting and jumping to topic windows
function list-topics {
  kitten @ ls | jq -r ".[].tabs[].windows[].user_vars.topic | select(. != null)"
}
function set-topic {
  if test -z "$1"; then
    echo "error: need topic argument"
    return 1
  fi
  kitten @ set-user-vars topic="$1"
}
function topics {
  f=`mktemp -t swwin XXXXXX`
  list-topics > "$f"
  topic=$(cat "$f" | fzf | tr -d "\n")
  rm -f "$f"
  kitten @ focus-window --match var:topic=$topic
}
function switch-tab {
  f=`mktemp -t swtab XXXXXX`
  list-topics > "$f"
  topic=$(cat "$f" | fzf | tr -d "\n")
  rm -f "$f"
  kitten @ focus-tab --match var:topic=$topic
}

# PS1 settings are for interactive shells (login or no), so they should be
# set in .bashrc.
# Colors the prompt red if the exit code argument isn't 0.
function __colorcode_exit {
    if test "$1" -eq 0; then
        print ";"
        #print "%{%B%};%{%b%}"
    else
        print "%{%F{red}%B%};%{%f%b%}"
    fi
}
function __colorcode_setps1 {
    local last_exit="$?"
    # I tried, at first, setting PS1 in .bashrc alone. But I ran into a problem
    # where the \[ and \] in __colorcode_exit were being literally printed in
    # the prompt, instead of interpreted as directives for bash. Setting PS1 in
    # PROMPT_COMMAND fixes this problem.
    PS1="$(__colorcode_exit $last_exit) "
}
mypromptcommand() {
  PS1="$(__colorcode_exit $?) "
}
precmd_functions+=(mypromptcommand)

# Base16 Shell
BASE16_SHELL="$HOME/.config/base16-shell/"
[ -n "$PS1" ] && \
    [ -s "$BASE16_SHELL/profile_helper.sh" ] && \
        source "$BASE16_SHELL/profile_helper.sh"

. $HOME/.zshrc_local
# vim: set filetype=zsh :
